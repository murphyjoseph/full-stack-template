# API Type Generation

End-to-end type safety from Prisma schema to React components, powered by OpenAPI.

## Pipeline

```
prisma/schema.prisma
  → Prisma Client (generated types for DB queries)
  → NestJS DTOs (class-validator + @ApiProperty decorators)
  → Swagger/OpenAPI spec (extracted by @nestjs/swagger)
  → openapi.json (written to packages/api-schema/)
  → schema.d.ts (generated by openapi-typescript)
  → openapi-fetch client (typed paths, request/response bodies)
  → openapi-react-query hooks (typed useQuery/useMutation)
```

## How It Works

### 1. NestJS DTOs Define the Contract

DTOs in `apps/server/src/contacts/dto/` use `class-validator` for runtime validation and `@ApiProperty` for Swagger schema generation:

```ts
// create-contact.dto.ts
export class CreateContactDto {
  @ApiProperty({ type: String })
  @IsString()
  name: string;
}
```

The `@nestjs/swagger` CLI plugin (configured in `nest-cli.json`) enhances DTO introspection automatically. However, since `tsx` doesn't support `emitDecoratorMetadata`, all `@ApiProperty` decorators must include an explicit `{ type: ... }` option.

### 2. OpenAPI Spec Generation

`apps/server/scripts/generate-openapi.ts` boots the NestJS app headlessly (no HTTP listener, no logging), creates the Swagger document, and writes it to `packages/api-schema/openapi.json`:

```ts
const app = await NestFactory.create(AppModule, { logger: false });
const document = SwaggerModule.createDocument(app, config);
writeFileSync(outputPath, JSON.stringify(document, null, 2));
```

Run: `pnpm generate:types` (or `pnpm --filter server generate:openapi` for just the JSON)

### 3. TypeScript Types from OpenAPI

`openapi-typescript` reads `openapi.json` and generates `src/schema.d.ts` with fully typed `paths`, `components`, and `operations` interfaces.

Run: `pnpm --filter @repo/api-schema generate`

### 4. Typed Fetch Client

`packages/api-schema/src/client.ts` wraps `openapi-fetch`:

```ts
import createFetchClient from "openapi-fetch";
import type { paths } from "./schema.js";

export function createApiClient(baseUrl: string) {
  return createFetchClient<paths>({ baseUrl });
}
```

Every API call is type-checked against the OpenAPI spec — wrong paths, missing body fields, or incorrect types are compile-time errors.

### 5. TanStack Query Integration

The React Query integration lives in the web app at `apps/web/external/api-schema/react-query.ts`, keeping React-specific dependencies out of the framework-agnostic `@repo/api-schema` package:

```ts
import createClient from "openapi-react-query";
import { createApiClient } from "@repo/api-schema";

export function createQueryApi(baseUrl: string) {
  const fetchClient = createApiClient(baseUrl);
  return createClient(fetchClient);
}
```

The web app creates the singleton in `app/api.ts`:

```ts
export const $api: QueryApi = createQueryApi(baseUrl);
```

Components use fully typed hooks:

```ts
const { data } = $api.useQuery("get", "/contacts");
// data is typed as ContactDto[]

const mutation = $api.useMutation("post", "/contacts");
// mutation.mutateAsync({ body }) requires CreateContactDto shape
```

## When to Regenerate

Run `pnpm generate:types` after:
- Adding, removing, or modifying NestJS controller endpoints
- Changing DTO properties or validation rules
- Adding new Swagger decorators

The committed `openapi.json` is the API contract. The `api-schema` package builds from it independently — no server required.
